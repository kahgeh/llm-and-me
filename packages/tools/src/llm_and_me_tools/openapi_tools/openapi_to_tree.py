import yaml
import json
import sys
from typing import List, Dict, Any


def generate_api_tree(openapi_spec: dict) -> dict:
    """Generates a tree structure of API paths from an OpenAPI specification dictionary."""
    paths = openapi_spec.get("paths", {})
    tree = {}
    for path, methods in paths.items():
        segments = [segment for segment in path.split("/") if segment]
        current_level = tree
        for segment in segments:
            if segment not in current_level:
                current_level[segment] = {}
            current_level = current_level[segment]
        for method_key in methods: # methods is a dict, method_key is e.g. 'get', 'post'
            current_level[f"[{method_key.upper()}]"] = None  # Mark as a leaf node
    return tree


def get_openapi_path_tree_from_content(openapi_content: str, content_type: str = "yaml") -> dict:
    """
    Parses OpenAPI content (YAML or JSON string) and generates a tree of API paths.
    content_type can be 'yaml' or 'json'.
    """
    spec: dict

    normalized_content_type = content_type.lower()

    if normalized_content_type == "yaml":
        try:
            spec = yaml.safe_load(openapi_content)
        except yaml.YAMLError as e:
            raise ValueError(f"Error parsing YAML content: {e}") from e
    elif normalized_content_type == "json":
        try:
            spec = json.loads(openapi_content)
        except json.JSONDecodeError as e:
            raise ValueError(f"Error parsing JSON content: {e}") from e
    else:
        raise ValueError("Unsupported content_type. Use 'yaml' or 'json'.")

    if not isinstance(spec, dict):
        raise ValueError(
            "Parsed OpenAPI content did not result in a dictionary. "
            "Please ensure the content is valid."
        )

    if "paths" not in spec:
        raise ValueError(
            "Invalid OpenAPI specification format. Missing 'paths' section."
        )

    return generate_api_tree(spec)


def _build_tree_string_lines_recursive(current_tree_level: Dict[str, Any], current_prefix: str, output_lines: List[str]):
    """
    Recursively builds the string representation of a tree level and appends formatted lines
    to the output_lines list.

    Args:
        current_tree_level: The dictionary representing the current level of the tree.
                            Keys are path segments or method markers, values are sub-trees or None.
        current_prefix: The string prefix (indentation and connectors) for lines at this level.
        output_lines: A list to which formatted string lines are appended.
    """
    items = list(current_tree_level.keys())
    num_items = len(items)
    for i, key in enumerate(items):
        is_last_item_in_level = i == num_items - 1
        marker = "└── " if is_last_item_in_level else "├── "
        output_lines.append(current_prefix + marker + key)

        subtree = current_tree_level[key]
        if isinstance(subtree, dict) and subtree:  # Check if subtree is a non-empty dictionary
            child_prefix = current_prefix + ("    " if is_last_item_in_level else "│   ")
            _build_tree_string_lines_recursive(subtree, child_prefix, output_lines)


def format_api_tree_as_string(api_tree: Dict[str, Any]) -> str:
    """
    Formats an API path tree dictionary into a human-readable, multi-line string representation.

    Args:
        api_tree: A dictionary representing the API path tree, as generated by
                  `generate_api_tree`.

    Returns:
        A string representing the formatted tree, or a message if no paths are found.
        Example:
        paths/
        └── users/
            ├── [GET]
            └── {id}/
                └── [GET]
    """
    if not api_tree: # Handles case where spec has "paths: {}" or no paths from generate_api_tree
        return "No API paths found in the specification."

    output_lines: List[str] = []
    output_lines.append("paths/")
    _build_tree_string_lines_recursive(api_tree, "", output_lines)
    return "\n".join(output_lines)


def get_openapi_path_tree_as_string(openapi_content: str, content_type: str = "yaml") -> str:
    """
    Parses OpenAPI content (YAML or JSON string) and generates a string
    representation of the API path tree.

    Args:
        openapi_content: A string containing the OpenAPI specification.
        content_type: The format of the content, either 'yaml' or 'json'.
                      Defaults to 'yaml'.

    Returns:
        A multi-line string representing the API path tree.

    Raises:
        ValueError: If the content_type is unsupported, or if there are errors
                    parsing the OpenAPI content, or if the content is not a valid
                    OpenAPI structure (e.g., missing 'paths').
    """
    api_tree_dict = get_openapi_path_tree_from_content(openapi_content, content_type)
    return format_api_tree_as_string(api_tree_dict)


def main():
    if len(sys.argv) != 2:
        print("Usage: python script_name.py <openapi_file>")
        sys.exit(1)

    openapi_file = sys.argv[1]

    try:
        with open(openapi_file, "r", encoding="utf-8") as f:
            openapi_spec_content = f.read()

            file_content_type = ""
            if openapi_file.endswith((".yaml", ".yml")):
                file_content_type = "yaml"
            elif openapi_file.endswith(".json"):
                file_content_type = "json"
            else:
                print(
                    "Error: Unsupported file format. Please provide a YAML or JSON OpenAPI specification."
                )
                sys.exit(1)

            api_tree_string = get_openapi_path_tree_as_string(openapi_spec_content, file_content_type)
            print(api_tree_string)

    except FileNotFoundError:
        print(f"Error: File not found: {openapi_file}")
        sys.exit(1)
    except ValueError as e: # Catch parsing errors from get_openapi_path_tree_from_content
        print(f"Error processing OpenAPI content: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
